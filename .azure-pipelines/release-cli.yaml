name: $(BuildDefinitionName)_$(SourceBranchName)_$(Date:yyyyMMdd)$(Rev:.r)

trigger:
  batch: true
  branches:
    include:
      - refs/tags/v*
  paths:
    include:
    - .azure-pipelines
    - src
    - msgraph-cli.sln

pool:
  name: Azure Pipelines
  vmImage: ubuntu-latest

variables:
  - name: repositoryConnection
    value: 'GitHub - calebkiage'
  - name: zipTemplate
    value: msgraph-cli-{0}-{1}.zip
  - name: buildConfiguration
    value: 'Release'
  - name: outputDir
    value: $(Build.ArtifactStagingDirectory)/publish
  - name: artifactsDownloadLocation
    value: $(Pipeline.Workspace)/artifacts
  - name: internalFeed
    value: "Graph Developer Experiences/microsoft-graph-packages" # Format projectName/feedName
  - name: branchOrTagName
    ${{ if in(variables['Build.SourceBranch'], 'refs/heads/main', 'refs/heads/dev') }}:
      value: 'latest'
    ${{ else }}: # Version from the tag. Can be a branch name. Only mainline branches use latest
      value: '$(Build.SourceBranchName)'
  - group: ESRP

#                   
# test -> build -> | sign |
#                  |------| -> upload
# srcScan -------> | scan |
stages:
  - stage: test
    displayName: Run tests
    dependsOn: []
    jobs:
      - job: test
        displayName: Run tests
        steps:
        - task: UseDotNet@2
          displayName: 'Use .NET 7'
          inputs:
            version: 7.x

        # Restore NuGet packages (enables cache by default)
        - template: templates/nuget-packages.yaml
          parameters:
            vstsFeedName: ${{variables.internalFeed}}

        - task: DotNetCoreCLI@2
          displayName: Run tests
          enabled: true
          inputs:
            command: test
            workingDirectory: $(Build.SourcesDirectory)
            arguments: --no-restore

  - stage: build
    displayName: Build CLI
    dependsOn: [test]
    jobs:
      - job: prepare
        displayName: Prepare build
        steps:
          - pwsh: |
              # Get the version
              $version = '$(branchOrTagName)'
              $version = $version.TrimStart('refs/tags/v')
              # Export version for use later
              Write-Host "##vso[task.setvariable variable=versionVar;isOutput=true]$version"
            name: version
      - job: build
        dependsOn: [prepare]
        displayName: Build and publish
        variables:
          version: $[ dependencies.prepare.outputs['version.versionVar'] ]
        strategy:
          matrix:
            'Windows-x64':
              rid: win-x64
            'Linux-x64':
              rid: linux-x64
            'MacOS-x64':
              rid: osx-x64
            'MacOS-ARM':
              rid: osx-arm64
          # maxParallel: 2
        steps:
          - task: UseDotNet@2
            displayName: 'Use .NET 7'
            inputs:
              version: 7.x

          - template: templates/nuget-packages.yaml
            parameters:
              vstsFeedName: ${{variables.internalFeed}}

          - pwsh: dotnet publish --no-restore --runtime $(rid) --self-contained true --configuration $(buildConfiguration) --output $(outputDir)
            workingDirectory: $(Build.SourcesDirectory)
            displayName: DotNet publish

          - pwsh: |
              # Get the archive name
              $zipName = '$(zipTemplate)' -f '$(rid)','$(version)'

              $outputLocation = '$(outputDir)-$(rid)'
              # Ensure output directory exists
              New-Item $outputLocation -ItemType Directory -Force
              Compress-Archive -Path $(outputDir)/* -DestinationPath $outputLocation/$zipName
              Remove-Item '$(outputDir)/*'
            displayName: Compress published output

          - task: PublishPipelineArtifact@1
            # Only publish artifacts if we're building a tag, main or testing a PR targeting main
            condition: and(succeeded(), or(startsWith('$(Build.SourceBranch)', 'refs/tags/v'), in('refs/heads/main', '$(System.PullRequest.TargetBranch)', '$(Build.SourceBranch)')))
            inputs:
              artifact: build-output-$(rid)
              path: $(outputDir)-$(rid)

  - stage: srcScan
    displayName: Scan source code
    pool:
      vmImage: windows-latest
    dependsOn: []
    jobs:
      - job: scan
        displayName: Scanning source
        steps:
          - template: templates/compliance-checks.yaml
            parameters:
              scanSource: true

  - stage: sign
    displayName: ESRP signing
    pool:
      vmImage: windows-latest
    dependsOn: [build]
    variables:
      version: $[ stageDependencies.build.prepare.outputs['version.versionVar'] ]
    # Only sign binaries if we're building a tag.
    condition: and(succeeded(), startsWith('$(Build.SourceBranch)', 'refs/tags/v'))
    jobs:
      - job: esrpSign
        dependsOn: []
        variables:
          macSignOp: |
            [
                {
                    "keyCode": "CP-401337-Apple",
                    "OperationCode": "MacAppDeveloperSign",
                    "Parameters": {
                      "Hardening": "--options=runtime"
                    },
                    "ToolName": "sign",
                    "ToolVersion": "1.0"
                }
            ]
          macNotarizeOp: |
            [
                {
                    "keyCode": "CP-401337-Apple",
                    "OperationCode": "MacAppNotarize",
                    "Parameters": {
                      "BundleId": "com.microsoft.microsoftgraphcli"
                    },
                    "ToolName": "sign",
                    "ToolVersion": "1.0"
                }
            ]
        strategy:
          matrix:
            'Windows-x64':
              rid: win-x64
              vmImage: windows-latest
              sign: true
              pattern: |
                **\*.exe
                **\*.dll
              inlineSignOperation: |
                [
                  {
                    "KeyCode": "CP-230012",
                    "OperationCode": "SigntoolSign",
                    "Parameters": {
                        "OpusName" : "Microsoft",
                        "OpusInfo" : "http://www.microsoft.com",
                        "FileDigest" : "/fd \"SHA256\"",
                        "PageHash" : "/NPH",
                        "TimeStamp" : "/tr \"http://rfc3161.gtm.corp.microsoft.com/TSS/HttpTspServer\" /td sha256"
                    },
                    "ToolName": "sign",
                    "ToolVersion": "1.0"
                  },
                  {
                    "KeyCode": "CP-230012",
                    "OperationCode": "SigntoolVerify",
                    "Parameters": {},
                    "ToolName": "sign",
                    "ToolVersion": "1.0"
                  }
                ]
              inlineNotarizeOperation: ""
            'MacOS-x64':
              rid: osx-x64
              vmImage: macOS-11
              sign: true
              inlineSignOperation: ${{ variables.macSignOp }}
              inlineNotarizeOperation: ${{ variables.macNotarizeOp }}
            'MacOS-ARM':
              rid: osx-arm64
              vmImage: macOS-12
              sign: true
              inlineSignOperation: ${{ variables.macSignOp }}
              inlineNotarizeOperation: ${{ variables.macNotarizeOp }}
        displayName: ESRP Signing
        pool:
          vmImage: $(vmImage)
        steps:
          - pwsh: |
              Write-Verbose -Verbose 'pattern = ''$(pattern)'''
              Write-Verbose -Verbose 'zipTemplate = ''$(zipTemplate)'''
              Write-Verbose -Verbose 'artifactsDownloadLocation = ''$(artifactsDownloadLocation)'''
              Write-Verbose -Verbose 'version = ''$(version)'''
              Write-Verbose -Verbose 'sign = ''$(sign)'''
              Write-Verbose -Verbose 'inlineSignOperation = ''$(inlineSignOperation)'''
              Write-Verbose -Verbose 'inlineNotarizeOperation = ''$(inlineNotarizeOperation)'''
              $rid = '$(rid)'
              $shouldSign = '$(sign)'
              $notarizeOp = '$(inlineNotarizeOperation)'
              Write-Host "##vso[task.setvariable variable=RUNTIME_ID]$rid"
              Write-Host "##vso[task.setvariable variable=SHOULD_SIGN]$shouldSign"
              Write-Host "##vso[task.setvariable variable=NOTARIZE_OPERATION]$notarizeOp"
              Write-Host "##vso[task.setvariable variable=WORKING_DIR]$(artifactsDownloadLocation)/$(rid)"
            displayName: Setup variables

          - task: DownloadPipelineArtifact@2
            inputs:
              patterns: build-output-$(rid)/**/*
              path: $(WORKING_DIR)
            condition: and(succeeded(), eq(variables['SHOULD_SIGN'], 'True'))
          
          - pwsh: |
              $zipName = '$(zipTemplate)' -f '$(rid)','$(version)'
              Write-Host "##vso[task.setvariable variable=ZIP_NAME]$zipName"
            displayName: Compute zip name

          - pwsh: |
              # Get the archive name
              # artifactsDownloadLocation = $(Pipeline.Workspace)/artifacts
              # WORKING_DIR = $(artifactsDownloadLocation)/$(rid)
              $downloadDir = Join-Path -Path '$(WORKING_DIR)' -ChildPath 'build-output-$(rid)'
              $zipPath = Join-Path -Path $downloadDir -ChildPath '$(ZIP_NAME)'
              Write-Host $zipPath
              $extractPath = Join-Path -Path '$(WORKING_DIR)' -ChildPath artifacts
              # extractPath = $(artifactsDownloadLocation)/$(rid)/artifacts
              Expand-Archive -Path $zipPath -DestinationPath $extractPath
              Get-ChildItem -Path '$(WORKING_DIR)' -Recurse -Force -ErrorAction SilentlyContinue | Select-Object FullName

              $backupPath = Join-Path -Path '$(WORKING_DIR)' -ChildPath backup
              # backupPath = $(artifactsDownloadLocation)/$(rid)/backup
              New-Item "$backupPath" -ItemType "Directory"
              # Move non-exe items
              Move-Item -Path $extractPath/* -Exclude mgc,mgc.exe -Destination "$backupPath"
              Get-ChildItem -Path '$(WORKING_DIR)' -Recurse -Force -ErrorAction SilentlyContinue | Select-Object FullName
              # -Force so there's no confirmation
              # -Recurse so the child items warning isn't shown
              Remove-Item $downloadDir -Recurse -Force
              Write-Host "##vso[task.setvariable variable=BACKUP_PATH]$backupPath"
            displayName: Extract zip
            condition: and(succeeded(), eq(variables['SHOULD_SIGN'], 'True'))

          - template: templates/prepare-unsigned-executable-darwin.yaml
            parameters:
              executablePath: $(WORKING_DIR)/artifacts
              executableName: mgc
              zipName: $(ZIP_NAME)
              targetRuntime: $(rid)

          - pwsh: |
              Write-Host "##vso[task.setvariable variable=ESRP_FILE_PATTERN]$(ZIP_NAME)"
            displayName: Compute ESRP filter pattern osx
            condition: and(succeeded(), startsWith(variables['RUNTIME_ID'], 'osx'))

          - pwsh: |
              Write-Host "##vso[task.setvariable variable=ESRP_FILE_PATTERN]$(pattern)"
            displayName: Compute ESRP filter pattern Windows
            condition: and(succeeded(), startsWith(variables['RUNTIME_ID'], 'win'))

          - task: EsrpCodeSigning@2
            displayName: 'ESRP CodeSigning (Sign)'
            inputs:
              # Pipeline validation can't expand service name from matrix variables
              ConnectedServiceName: "microsoftgraph ESRP CodeSign DLL and NuGet (AKV)"
              FolderPath: $(WORKING_DIR)/artifacts
              signConfigType: inlineSignParams
              UseMinimatch: true
              Pattern: $(ESRP_FILE_PATTERN)
              inlineOperation: $(inlineSignOperation)
              SessionTimeout: 20
            condition: and(succeeded(), eq(variables['SHOULD_SIGN'], 'True'))

          - task: EsrpCodeSigning@2
            displayName: 'ESRP CodeSigning (Notarize)'
            inputs:
              # Pipeline validation can't expand service name from matrix variables
              ConnectedServiceName: "microsoftgraph ESRP CodeSign DLL and NuGet (AKV)"
              FolderPath: $(WORKING_DIR)/artifacts
              signConfigType: inlineSignParams
              UseMinimatch: true
              Pattern: $(ESRP_FILE_PATTERN)
              inlineOperation: $(inlineNotarizeOperation)
              SessionTimeout: 20
            condition: and(succeeded(), gt(length(variables['NOTARIZE_OPERATION']), 0), ne(variables['NOTARIZE_OPERATION'], '$(inlineNotarizeOperation)'), eq(variables['SHOULD_SIGN'], 'True'))

          - pwsh: |
              $artifactsPath = "$(WORKING_DIR)/artifacts"
              Get-ChildItem -Path '$(WORKING_DIR)' -Recurse -Force -ErrorAction SilentlyContinue | Select-Object FullName
              # artifactsPath = $(artifactsDownloadLocation)/$(rid)/artifacts
              Move-Item -Path "$artifactsPath/*.md" -Destination "$(WORKING_DIR)"
              # Move backup back
              # BACKUP_PATH = $(artifactsDownloadLocation)/$(rid)/backup
              Move-Item -Path '$(BACKUP_PATH)/*' -Destination "$artifactsPath"
              Compress-Archive -Path "$artifactsPath/*" -DestinationPath $(WORKING_DIR)/$(ZIP_NAME)
              Remove-Item "$artifactsPath" -Recurse -Force
              Remove-Item '$(BACKUP_PATH)' -Recurse -Force
              Get-ChildItem -Path '$(WORKING_DIR)' -Recurse -Force -ErrorAction SilentlyContinue | Select-Object FullName
            displayName: Compress signed files (Windows)
            condition: and(succeeded(), eq(variables['SHOULD_SIGN'], 'True'), startsWith(variables['RUNTIME_ID'], 'win'))

          - pwsh: |
              $artifactsPath = "$(WORKING_DIR)/artifacts"
              Get-ChildItem -Path '$(WORKING_DIR)' -Recurse -Force -ErrorAction SilentlyContinue | Select-Object FullName
              $zipPath = Join-Path -Path $artifactsPath -ChildPath '$(ZIP_NAME)'
              Expand-Archive -Path "$zipPath" -DestinationPath "$artifactsPath"
              Move-Item -Path "$artifactsPath/*.md" -Destination "$(WORKING_DIR)"
              Remove-Item -Path "$zipPath" -Force
              Move-Item -Path '$(BACKUP_PATH)/*' -Destination "$artifactsPath"
              Compress-Archive -Path "$artifactsPath/*" -DestinationPath $(WORKING_DIR)/$(ZIP_NAME)
              Remove-Item "$artifactsPath" -Recurse -Force
              Remove-Item '$(BACKUP_PATH)' -Recurse -Force
              Get-ChildItem -Path '$(WORKING_DIR)' -Recurse -Force -ErrorAction SilentlyContinue | Select-Object FullName
            displayName: Update signed files (MacOS)
            condition: and(succeeded(), eq(variables['SHOULD_SIGN'], 'True'), startsWith(variables['RUNTIME_ID'], 'osx'))

          - task: PublishPipelineArtifact@1
            inputs:
              artifact: sign-output-$(rid)
              path: $(WORKING_DIR)
            condition: and(succeeded(), eq(variables['SHOULD_SIGN'], 'True'))

  - stage: binaryScan
    displayName: Scan binaries (Anti malware, BinSkim)
    dependsOn: [build, srcScan]
    pool:
      vmImage: windows-latest
    # Only publish artifacts if we're building a tag, main or testing a PR targeting main
    condition: and(succeeded(), or(startsWith('$(Build.SourceBranch)', 'refs/tags/v'), in('refs/heads/main', '$(System.PullRequest.TargetBranch)', '$(Build.SourceBranch)')))
    jobs:
      - job: scan
        displayName: Scanning binaries
        steps:
          - template: templates/compliance-checks.yaml
            parameters:
              artifactsDownloadLocation: $(artifactsDownloadLocation)
              scanBinary: true

  - stage: upload
    dependsOn: [binaryScan, sign]
    # Only upload release if we're building a tag.
    condition: and(succeeded(), startsWith('$(Build.SourceBranch)', 'refs/tags/v'))
    variables:
      currentTag: '$(branchOrTagName)'
      isPreRelease: $[ contains(variables.currentTag, 'preview') ]
    jobs:
      - job: upload
        displayName: Upload binaries
        steps:
          - checkout: none
          - task: DownloadPipelineArtifact@2
            inputs:
              path: $(artifactsDownloadLocation)
          - task: GithubRelease@1
            displayName: 'Create GitHub Draft Release'
            inputs:
              gitHubConnection: $(repositoryConnection)
              repositoryName: '$(Build.Repository.Name)'
              action: create
              tagSource: 'gitTag'
              isDraft: true
              addChangeLog: true
              changeLogCompareToRelease: lastNonDraftRelease
              assets: |
                $(artifactsDownloadLocation)/build-output-linux-*/*.zip
                $(artifactsDownloadLocation)/sign-output-*/*.zip
              isPreRelease: $(isPreRelease)
    