name: Release CLI

trigger:
  branches:
    include:
      - refs/tags/v*

pool:
  name: Azure Pipelines
  vmImage: ubuntu-latest

variables:
  - name: sourceRepository
    value: 'microsoftgraph/msgraph-cli'
  - name: repositoryConnection
    value: 'GitHub - calebkiage'
  - name: zipTemplate
    value: msgraph-cli-{0}-{1}.zip
  - name: buildConfiguration
    value: 'Release'
  - name: outputDir
    value: $(Build.ArtifactStagingDirectory)/publish
  - name: artifactsDownloadLocation
    value: $(Pipeline.Workspace)/artifacts
  - name: internalFeed
    value: "Graph Developer Experiences/microsoft-graph-packages" # Format projectName/feedName
  - name: versionString
    value: $[ coalesce('${{parameters.tag}}', '$(Build.SourceBranch)', 'v0.1.0') ]
  - group: ESRP

parameters:
  - name: tag
    displayName: Tag
    type: string
    default:

#                   
# test -> build -> | sign |
#                  |------| -> upload
# srcScan -------> | scan |
stages:
  - stage: test
    displayName: Run tests
    dependsOn: []
    jobs:
      - job: test
        displayName: Run tests
        steps:
        - task: UseDotNet@2
          displayName: 'Use .NET 6'
          inputs:
            version: 6.x

        # Restore NuGet packages (enables cache by default)
        - template: templates/nuget-packages.yaml
          parameters:
            vstsFeedName: ${{variables.internalFeed}}

        - task: DotNetCoreCLI@2
          displayName: Run tests
          enabled: true
          inputs:
            command: test
            workingDirectory: $(Build.SourcesDirectory)
            arguments: --no-restore
  - stage: build
    displayName: Build CLI
    dependsOn: [test]
    jobs:
      - job: prepare
        displayName: Prepare build
        steps:
          - pwsh: |
              # Get the version
              $version = '$(versionString)'
              $version = $version.TrimStart('refs/tags/').TrimStart('v')
              # Export version for use later
              Write-Host "##vso[task.setvariable variable=versionVar;isOutput=true]$version"
            name: version
      - job: build
        dependsOn: [prepare]
        displayName: Build and publish
        variables:
          version: $[ dependencies.prepare.outputs['version.versionVar'] ]
        strategy:
          matrix:
            'Windows-x64':
              rid: win-x64
            'Linux-x64':
              rid: linux-x64
            'MacOS-x64':
              rid: osx-x64
            'MacOS-ARM':
              rid: osx-arm64
          # maxParallel: 2
        steps:
          - task: UseDotNet@2
            displayName: 'Use .NET 6'
            inputs:
              version: 6.x

          - template: templates/nuget-packages.yaml
            parameters:
              vstsFeedName: ${{variables.internalFeed}}

          - pwsh: dotnet publish --no-restore --runtime $(rid) --self-contained true --configuration $(buildConfiguration) --output $(outputDir)
            workingDirectory: $(Build.SourcesDirectory)
            displayName: DotNet publish

          - pwsh: |
              # Get the archive name
              $zipName = '$(zipTemplate)' -f '$(rid)','$(version)'

              $outputLocation = '$(outputDir)-$(rid)'
              # Ensure output directory exists
              New-Item $outputLocation -ItemType Directory -Force
              Compress-Archive -Path $(outputDir)/* -DestinationPath $outputLocation/$zipName
              Remove-Item '$(outputDir)/*'
            displayName: Compress published output

          - task: PublishPipelineArtifact@1
            inputs:
              artifact: build-output-$(rid)
              path: $(outputDir)-$(rid)

  - stage: srcScan
    displayName: Scan source code
    pool:
      vmImage: windows-latest
    dependsOn: []
    jobs:
      - job: scan
        displayName: Scanning source
        steps:
          - template: templates/compliance-checks.yaml
            parameters:
              scanSource: true
  - stage: sign
    displayName: ESRP signing
    pool:
      vmImage: windows-latest
    dependsOn: [build]
    variables:
      version: $[ stageDependencies.build.prepare.outputs['version.versionVar'] ]
    jobs:
      - job: esrpSign
        dependsOn: []
        strategy:
          matrix:
            'Windows-x64':
              rid: win-x64
              sign: true
              pattern: |
                **\*.exe
                **\*.dll
            'MacOS-x64':
              rid: osx-x64
              notarize: false
              sign: false
              pattern: |
                **\*.zip
            'MacOS-ARM':
              rid: osx-arm64
        displayName: ESRP Signing
        steps:
          - pwsh: |
              Write-Verbose -Verbose "signingServiceName = '`$(signingServiceName)'"
              Write-Verbose -Verbose "pattern = '`$(pattern)'"
              Write-Verbose -Verbose "zipTemplate = '`$(zipTemplate)'"
              Write-Verbose -Verbose "artifactsDownloadLocation = '`$(artifactsDownloadLocation)'"
              Write-Verbose -Verbose "version = '`${{ variables.version }}'"
              $rid = '`$(rid)'
              $shouldSign = '`$(sign)'
              $shouldNotarize = '`$(notarize)'
              Write-Host ##vso[task.setvariable variable=RUNTIME_ID]$rid
              Write-Host ##vso[task.setvariable variable=SHOULD_SIGN]$shouldSign
              Write-Host ##vso[task.setvariable variable=SHOULD_NOTARIZE]$shouldNotarize
          - task: DownloadPipelineArtifact@2
            inputs:
              patterns: build-output-$(rid)/**/*
              path: $(artifactsDownloadLocation)/$(rid)
            condition: and(succeeded(), eq(variables['SHOULD_SIGN'], 'True'))
          - pwsh: |
              # Get the archive name
              $downloadDir = Join-Path -Path '$(artifactsDownloadLocation)/$(rid)/' -ChildPath 'build-output-$(rid)'
              Get-ChildItem $downloadDir
              $zipName = '$(zipTemplate)' -f '$(rid)','${{ variables.version }}'
              $zipPath = Join-Path -Path $downloadDir -ChildPath $zipName
              Write-Host $zipPath
              Expand-Archive -Path $zipPath -DestinationPath '../'
              Get-ChildItem $downloadDir
              Remove-Item $zipPath
            displayName: Extract zip
            condition: and(succeeded(), eq(variables['SHOULD_SIGN'], 'True'))
          # - task: EsrpCodeSigning@2
          #   displayName: 'ESRP CodeSigning'
          #   inputs:
          #     ConnectedServiceName: 'microsoftgraph ESRP CodeSign DLL and NuGet (AKV)'
          #     FolderPath: $(artifactsDownloadLocation)/$(rid)/build-output-$(rid)
          #     signConfigType: inlineSignParams
          #     UseMinimatch: true
          #     Pattern: $(pattern)
          #     inlineOperation: |
          #       [
          #           {
          #               "keyCode": "CP-230012",
          #               "operationSetCode": "SigntoolSign",
          #               "parameters": {
          #                 "OpusName" : "Microsoft",
          #                 "OpusInfo" : "http://www.microsoft.com",
          #                 "FileDigest" : "/fd \"SHA256\"",
          #                 "PageHash" : "/NPH",
          #                 "TimeStamp" : "/tr \"http://rfc3161.gtm.corp.microsoft.com/TSS/HttpTspServer\" /td sha256"
          #               },
          #               "toolName": "sign",
          #               "toolVersion": "1.0"
          #           },
          #           {
          #               "keyCode": "CP-230012",
          #               "operationSetCode": "SigntoolVerify",
          #               "parameters": {},
          #               "toolName": "sign",
          #               "toolVersion": "1.0"
          #           }
          #       ]
          #     SessionTimeout: 20
          #   condition: and(succeeded(), startsWith(variables['RUNTIME_ID'], 'win'), eq(variables['SHOULD_SIGN'], 'True'))
          # - task: EsrpCodeSigning@2
          #   displayName: 'ESRP CodeSigning'
          #   inputs:
          #     ConnectedServiceName: 'microsoftgraph ESRP CodeSign DLL and NuGet (AKV)'
          #     FolderPath: $(artifactsDownloadLocation)/$(rid)/build-output-$(rid)
          #     signConfigType: inlineSignParams
          #     UseMinimatch: true
          #     Pattern: $(pattern)
          #     inlineOperation: |
          #       [
          #           {
          #               "keyCode": "CP-401337-Apple",
          #               "OperationCode": "MacAppDeveloperSign",
          #               "Parameters": {
          #                 "Hardening": "--options=runtime"
          #               },
          #               "ToolName": "sign",
          #               "ToolVersion": "1.0
          #           },
          #       ]
          #     SessionTimeout: 20
          #   condition: and(succeeded(), startsWith(variables['RUNTIME_ID'], 'osx'), eq(variables['SHOULD_SIGN'], 'True'))
          # - task: EsrpCodeSigning@2
          #   displayName: 'ESRP CodeSigning'
          #   inputs:
          #     ConnectedServiceName: 'microsoftgraph ESRP CodeSign DLL and NuGet (AKV)'
          #     FolderPath: $(artifactsDownloadLocation)/$(rid)/build-output-$(rid)
          #     signConfigType: inlineSignParams
          #     UseMinimatch: true
          #     Pattern: $(pattern)
          #     inlineOperation: |
          #       [
          #           {
          #               "keyCode": "CP-401337-Apple",
          #               "OperationCode": "MacAppNotarize",
          #               "Parameters": {
          #                 "BundleId": "com.microsoft.microsoftgraphcli"
          #               },
          #               "ToolName": "sign",
          #               "ToolVersion": "1.0
          #           },
          #       ]
          #     SessionTimeout: 20
          #   condition: and(succeeded(), startsWith(variables['RUNTIME_ID'], 'osx'), eq(variables['SHOULD_SIGN'], 'True'), eq(variables['SHOULD_NOTARIZE'], 'True'))

          - pwsh: |
              $zipName = '$(zipTemplate)' -f '$(rid)','${{ variables.version }}'
              Compress-Archive -Path '$(Build.StagingDirectory)/signed/output/*' -DestinationPath ../$zipName
              Remove-Item '$(Build.StagingDirectory)/signed/original' -Force
            displayName: Compress signed files
            condition: and(succeeded(), eq(variables['SHOULD_SIGN'], 'True'))

          - task: PublishPipelineArtifact@1
            inputs:
              artifact: sign-output-$(rid)
              path: $(Build.StagingDirectory)/signed
            condition: and(succeeded(), eq(variables['SHOULD_SIGN'], 'True'))

  - stage: binaryScan
    displayName: Scan binaries (Anti malware, BinSkim)
    dependsOn: [build, srcScan]
    pool:
      vmImage: windows-latest
    jobs:
      - job: scan
        displayName: Scanning binaries
        steps:
          - template: templates/compliance-checks.yaml
            parameters:
              artifactsDownloadLocation: $(artifactsDownloadLocation)
              scanBinary: true

  - stage: upload
    dependsOn: [binaryScan, sign]
    jobs:
      - job: upload
        displayName: Upload binaries
        steps:
          - checkout: none
          - pwsh: |
              echo "TODO: Upload"
    